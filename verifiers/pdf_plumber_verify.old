
"""
Lightweight PDF verification for Chase statements using pdfplumber.
"""
from __future__ import annotations
import re
from typing import Dict, Optional, Any

try:
    import pdfplumber  # type: ignore
except Exception:
    pdfplumber = None

AMOUNT_RE = re.compile(r'\$?\s*\d{1,3}(?:,\d{3})*\.\d{2}')
BEGIN_BAL_RE = re.compile(r'Beginning\s+Balance\s+(\$?\s*\d{1,3}(?:,\d{3})*\.\d{2})', re.I)
END_BAL_RE   = re.compile(r'(Ending|Closing)\s+Balance\s+(\$?\s*\d{1,3}(?:,\d{3})*\.\d{2})', re.I)
TOT_DEP_RE   = re.compile(r'Total\s+Deposits\s+and\s+Additions\s+(\$?\s*\d{1,3}(?:,\d{3})*\.\d{2})', re.I)
TOT_WD_RE    = re.compile(r'Total\s+(?:ATM\s*&\s*Debit\s*Card\s+)?Withdrawals(?:\s+and\s+Debits)?\s+(\$?\s*\d{1,3}(?:,\d{3})*\.\d{2})', re.I)

def _to_float(txt: str) -> float:
    s = txt.strip().replace("$","").replace(",","")
    neg = False
    if s.endswith('-'):
        neg, s = True, s[:-1]
    if s.startswith("(") and s.endswith(")"):
        neg, s = True, s[1:-1]
    v = float(s)
    return -v if neg else v

def _fmt_amt(v: float) -> str:
    return f"{abs(v):,.2f}"

def _mk_date_tokens(date_str: str):
    mm = date_str[5:7]; dd = date_str[8:10]
    return [f"{mm}/{dd}", f"{int(mm)}/{int(dd)}", f"{mm}-{dd}", f"{int(mm)}-{int(dd)}"]

def _page_texts(pdf):
    return [(p.extract_text() or "") for p in pdf.pages]

def parse_pdf_totals(pdf_path: str):
    if pdfplumber is None:
        return {"begin": None, "end": None, "total_deposits": None, "total_withdrawals": None}
    try:
        with pdfplumber.open(pdf_path) as pdf:
            begin = end = dep = wd = None
            for txt in _page_texts(pdf):
                if begin is None:
                    m = BEGIN_BAL_RE.search(txt)
                    if m: begin = _to_float(m.group(1))
                if end is None:
                    m = END_BAL_RE.search(txt)
                    if m: end = _to_float(m.group(2))
                if dep is None:
                    m = TOT_DEP_RE.search(txt)
                    if m: dep = _to_float(m.group(1))
                if wd is None:
                    m = TOT_WD_RE.search(txt)
                    if m: wd = _to_float(m.group(1))
            return {"begin": begin, "end": end, "total_deposits": dep, "total_withdrawals": wd}
    except Exception:
        return {"begin": None, "end": None, "total_deposits": None, "total_withdrawals": None}

def verify_statement_pdf(pdf_path: str, df, begin_balance: Optional[float], end_balance: Optional[float], *, max_fail: int = 50, debug: bool=False) -> Dict[str, Any]:
    report = {"issues": [], "summary": {}, "by_page": {}}
    if pdfplumber is None:
        report["summary"] = {"status": "skipped", "reason": "pdfplumber not installed"}
        return report
    try:
        with pdfplumber.open(pdf_path) as pdf:
            page_texts = _page_texts(pdf)
            rows_checked = rows_found = 0
            hits = {i+1:0 for i in range(len(page_texts))}
            for idx, row in df.iterrows():
                if str(row.get("_src","")).upper() == "ADJUST":
                    continue
                date_tokens = _mk_date_tokens(str(row["Date"].date()))
                amt_token = _fmt_amt(float(row["Amount"]))
                page_for_date = page_for_amt = None
                found_same = False
                for pageno, txt in enumerate(page_texts, start=1):
                    has_date = any(tok in txt for tok in date_tokens)
                    has_amt  = (amt_token in txt) or (("$"+amt_token) in txt)
                    if has_date and page_for_date is None: page_for_date = pageno
                    if has_amt  and page_for_amt  is None: page_for_amt  = pageno
                    if has_date and has_amt:
                        hits[pageno]+=1; found_same=True; break
                rows_checked += 1
                if found_same:
                    rows_found += 1
                else:
                    report["issues"].append({
                        "RowIndex": int(idx),
                        "Date": str(row["Date"].date()),
                        "Amount": float(row["Amount"]),
                        "Description": str(row["Description"]),
                        "PageForDate": page_for_date,
                        "PageForAmount": page_for_amt,
                    })
            pdf_totals = parse_pdf_totals(pdf_path)
            report["by_page"] = hits
            report["summary"] = {
                "status": "ok",
                "rows_checked": rows_checked,
                "rows_matched_same_page": rows_found,
                "rows_missing": rows_checked - rows_found,
                "begin_balance_txt": pdf_totals.get("begin"),
                "end_balance_txt": pdf_totals.get("end"),
                "total_deposits_txt": pdf_totals.get("total_deposits"),
                "total_withdrawals_txt": pdf_totals.get("total_withdrawals"),
                "begin_balance_calc": begin_balance,
                "end_balance_calc": end_balance,
            }
            return report
    except Exception as e:
        report["summary"] = {"status": "error", "reason": str(e)}
        return report
